{"ast":null,"code":"(function () {\n  \"use strict\";\n\n  var colors = require('colors');\n\n  var fs = require('fs');\n\n  var _ = require('underscore');\n\n  var path = require('path');\n\n  var ujs = require('uglify-js');\n\n  var jshint = require('jshint').JSHINT;\n\n  var sys = require('sys');\n\n  var mustache = require('./mustache.js');\n\n  var util = require('util');\n\n  var EventEmitter = require('events').EventEmitter;\n\n  function Fuse() {\n    this.settings = {}; // setup the regular expressions\n\n    this.re = this.reJS = /\\/\\/ ?@(?:depends|import|include) (.+)\\b/gi;\n    this.reHTML = /<!--\\s?@(?:depends|import|include)\\s(.+?)\\s?-->/gi; // not watching by default\n\n    this.watching = false; // create an array to hold the watches for this fuse\n\n    this.files = [];\n    return this;\n  }\n\n  util.inherits(Fuse, EventEmitter);\n\n  Fuse.prototype.set = function (setting, val) {\n    this.settings[setting] = val;\n    return this;\n  };\n\n  Fuse.prototype.get = function (setting) {\n    return this.settings[setting];\n  };\n\n  Fuse.prototype.watch = function (inputFile, outputFile, fuseImmediately) {\n    var _this = this;\n\n    if (arguments.length === 1) {\n      fuseImmediately = inputFile;\n      inputFile = undefined;\n    }\n\n    if (inputFile) this.set('inputFile', inputFile);\n    if (outputFile) this.set('outputFile', outputFile);\n    if (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n    if (this.get('outputFile') === undefined) throw new Error('You must define the output file.'); // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\n    this.mode = path.extname(this.get('inputFile')).replace(/^\\./, ''); // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // define the watching mode\n\n    this.watching = true; // retrieve a list of files to watch\n\n    var aFiles = this.scanFiles();\n    var relativePath = path.dirname(this.get('inputFile')) + '/'; // loop through an setup a watch on each referenced file\n\n    _(aFiles).each(function (path) {\n      _this.watchSrcFile(relativePath + path.path);\n\n      _this.files.push(relativePath + path.path);\n    }); // we also need to watch the input file\n\n\n    this.watchFile(this.get('inputFile'));\n    this.files.push(this.get('inputFile'));\n    if (fuseImmediately) this.fuseFile();\n    return this;\n  };\n\n  Fuse.prototype.scanFiles = function () {\n    return this.getReferencedFiles(this.getFileContent(this.get('inputFile')), this.regex);\n  };\n\n  Fuse.prototype.checkReferences = function (references) {\n    var _this = this,\n        files = [this.get('inputFile')],\n        relativePath = path.dirname(this.get('inputFile')) + '/',\n        unwatched = false; // find references that are missing from files (these are files that need to be watched)\n\n\n    references.forEach(function (reference) {\n      var found = _this.files.some(function (file) {\n        return path.resolve(file) === path.resolve(relativePath, reference.path);\n      }); // add the file regardless if its found or not, because we're rebulding the files array\n\n\n      files.push(relativePath + reference.path); // if the file is in the files array, let's add it and start watching\n\n      if (!found) _this.watchSrcFile(relativePath + reference.path);\n    }); // find files that are missing from references (this are files that need to be unwatched)\n\n    this.files.forEach(function (file) {\n      // ignore the input file, we've already added this\n      if (file === _this.get('inputFile')) return; // search for this file in references\n\n      var found = references.some(function (reference) {\n        return path.resolve(file) === path.resolve(relativePath, reference.path);\n      }); // references is newer then file, so it may have been removed\n\n      if (!found) {\n        _this.unwatchSrcFile(file);\n\n        unwatched = true;\n      }\n    }); // update the old array, with the new one\n\n    this.files = files;\n    return unwatched;\n  };\n\n  Fuse.prototype.formatTime = function () {\n    var d = new Date();\n    return [d.getHours(), ':', d.getMinutes(), '.', d.getSeconds()].join('');\n  }; // core function for parsing and outputing a fused file\n  // uses fuseContent to do the heavy lifting\n\n\n  Fuse.prototype.fuseFile = function (inputFile, outputFile) {\n    if (inputFile !== undefined) this.set('inputFile', inputFile);\n    if (outputFile !== undefined) this.set('outputFile', outputFile);\n    if (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n    if (this.get('outputFile') === undefined) throw new Error('You must define the output file.'); // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\n    this.mode = path.extname(this.get('inputFile')).replace(/^\\./, ''); // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // work out the settings\n    // do we need to compress (js only)?\n\n    this.compress = this.get('compress') !== undefined ? this.get('compress') && this.mode === 'js' : false; // do we need to mangle (js only)?\n\n    this.mangle = this.get('mangle') !== undefined ? this.get('mangle') && this.mode === 'js' : false; // do we need to run the files through JSHint (js only)?\n\n    this.lint = this.get('lint') !== undefined ? this.get('lint') && this.mode === 'js' : false; // grab the content of the input file\n\n    var content = this.getFileContent(this.get('inputFile')); // determine the relative path we need to work from\n\n    var relativePath = path.dirname(path.normalize(this.get('inputFile'))); // grab a list of the referenced files\n\n    var matches = this.getReferencedFiles(content, this.regex); // output is a version of the content that we'll update\n\n    var output = content; // uglify-js2 variables\n\n    var ast = null;\n    var compressedAst = null;\n    var compressor = null;\n    var lintResult = null;\n    var lintData = {};\n\n    var _this = this;\n\n    var unwatched = false; // do we need to check the references?\n\n    if (this.watching) unwatched = this.checkReferences(matches); // are we linting?\n    // if so, lint the input file\n\n    if (this.lint) {\n      lintData[path.basename(this.get('inputFile'))] = this.lintFile(content);\n    } // if there is no matches, lint if required, emit nofuse event and stop processing\n\n\n    if (!matches.length && unwatched === false) {\n      // we still want to write to disk, but just the original content\n      fs.writeFile(_this.get('outputFile'), output, function (err) {\n        if (err) {\n          _this.emit('error', err);\n        } else {\n          // run the lint report\n          if (_this.lint) _this.lintReport(lintData);\n\n          _this.emit('nofuse', {\n            updated: _this.get('outputFile'),\n            fused: matches\n          });\n        }\n      });\n    } else {\n      // do we need to need lint?\n      if (this.lint) {\n        _.each(matches, function (match) {\n          // we're loading the files twice now, which isn't good\n          // need to implement a quick cache per sweep so that we can have multiple passes\n          // of file content, without multiple loads\n          var fileContent;\n          var filename = path.basename(match.path);\n          var filepath = path.join(relativePath, match.path);\n          fileContent = _this.getFileContent(filepath);\n          lintData[filename] = _this.lintFile(fileContent);\n        });\n      }\n\n      this.fuse(content, matches, relativePath, function (err, results) {\n        if (err) return _this.emit('error', err);\n        var output = results; // use uglify-js2 to minify the code if arguments are present\n\n        if (_this.compress || _this.mangle) {\n          // setup the compressor\n          compressor = ujs.Compressor({\n            warnings: false\n          }); // parse the output and create an AST\n\n          ast = ujs.parse(output); // should we compress?\n\n          if (_this.compress) {\n            ast.figure_out_scope();\n            compressedAst = ast.transform(compressor);\n          } // should we mangle?\n\n\n          if (_this.mangle) {\n            (compressedAst || ast).figure_out_scope();\n            (compressedAst || ast).compute_char_frequency();\n            (compressedAst || ast).mangle_names();\n          } // generate the new code string\n\n\n          output = (compressedAst || ast).print_to_string();\n        } // save the file to disk\n\n\n        fs.writeFile(_this.get('outputFile'), output, function (err) {\n          if (err) {\n            _this.emit('error', err);\n          } else {\n            _this.emit('fuse', {\n              updated: _this.get('outputFile'),\n              fused: matches.map(function (match) {\n                return match.path;\n              })\n            });\n          } // run the lint report\n\n\n          if (_this.lint) _this.lintReport(lintData);\n        });\n      });\n    }\n  }; // core function for parsing and generating output for a file\n\n\n  Fuse.prototype.fuseContent = function (content, relativePath, mode) {\n    // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n    this.mode = mode; // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // grab a list of the referenced files\n\n    var matches = this.getReferencedFiles(content, this.regex),\n        // output is a version of the content that we'll update\n    output = content,\n        _this = this; // do we have anything to combine?\n\n\n    if (!matches.length) {\n      return this.emit('nofuse', {\n        updated: content,\n        fused: matches\n      });\n    }\n\n    this.fuse(content, matches, relativePath, function (err, results) {\n      if (err) {\n        return _this.emit('error', err);\n      }\n\n      _this.emit('fuse', {\n        updated: results,\n        fused: matches.map(function (match) {\n          return match.path;\n        })\n      });\n    });\n  }; // lower-level to simply fuse the content provided a bunch of matches\n\n\n  Fuse.prototype.fuse = function (content, matches, relativePath, callback) {\n    var output = content,\n        _this = this; // loop through each match, grab the file content\n\n\n    _.each(matches, function (match) {\n      // ok, determine the file name\n      var fileContent;\n      var filename = path.basename(match.path);\n      var filepath = path.join(relativePath, match.path);\n      fileContent = _this.getFileContent(filepath); // let's replace the match with the filecontent\n\n      output = output.replace(match.str, fileContent);\n    });\n\n    callback(null, output);\n  };\n\n  Fuse.prototype.lintReport = function (lintData) {\n    var buffer = ''; // loop through the linting results and output any suggestions\n\n    for (var file in lintData) {\n      // skip the files that didn't contain errors\n      if (lintData[file] !== true) {\n        buffer += colors.red(file) + ' contains lint:'.red + '\\n';\n\n        for (var err in lintData[file]) {\n          lintData[file][err].evidence = lintData[file][err].evidence.trim();\n          buffer += mustache.render('   Error on line {{line}} at position {{character}}, {{reason}} \\'' + '{{evidence}}'.magenta + '\\'\\n', lintData[file][err]);\n        }\n      }\n    }\n\n    if (buffer.length) {\n      this.emit('lint', buffer + '\\r');\n    }\n  };\n\n  Fuse.prototype.lintFile = function (content) {\n    var lintResult = jshint(content);\n    return lintResult || jshint.errors;\n  }; // watch the input file for changes, if it does, we need to compile a new output file\n\n\n  Fuse.prototype.watchFile = function (inputFile) {\n    var _this = this,\n        inputFileName = path.basename(inputFile);\n\n    fs.watchFile(inputFile, {\n      'persistent': true,\n      'interval': 1000\n    }, function (curr, prev) {\n      if (curr.mtime.getTime() !== prev.mtime.getTime()) {\n        _this.emit('change', inputFileName);\n\n        _this.fuseFile();\n      }\n    });\n\n    _this.emit('watch', inputFile);\n  }; // watch a referenced file for changes, if it does, we need to compile a new output file\n\n\n  Fuse.prototype.watchSrcFile = function (srcFile) {\n    var _this = this,\n        srcFileName = path.basename(srcFile);\n\n    fs.watchFile(srcFile, {\n      'persistent': true,\n      'interval': 1000\n    }, function (curr, prev) {\n      if (curr.mtime.getTime() !== prev.mtime.getTime()) {\n        _this.emit('change', srcFileName);\n\n        _this.fuseFile();\n      }\n    });\n\n    _this.emit('watch', srcFile);\n  }; // unwatch a referenced file for changes\n\n\n  Fuse.prototype.unwatchSrcFile = function (srcFile) {\n    var _this = this,\n        srcFileName = path.basename(srcFile);\n\n    fs.unwatchFile(srcFile);\n\n    _this.emit('unwatch', srcFile);\n  }; // we assume this file has been verified by loadFile\n\n\n  Fuse.prototype.getFileContent = function (inputFile) {\n    try {\n      return fs.readFileSync(inputFile, 'utf-8');\n    } catch (e) {\n      this.emit('error', e);\n      return '';\n    }\n  }; // get a list of the files to include, from the input file\n\n\n  Fuse.prototype.getReferencedFiles = function (content, regex) {\n    var paths = [];\n    var matches = content.match(regex);\n\n    _.each(matches, function (match) {\n      // ok, determine the file name\n      var filepath = match.replace(regex, '$1'); // return the filepath, and the original string\n\n      paths.push({\n        'path': filepath,\n        \"str\": match\n      });\n    });\n\n    return paths;\n  }; // return only the filename, removing the actual file path\n\n\n  Fuse.prototype.getFileName = function (path) {\n    return path.replace(/.*\\/(.*)/i, '$1');\n  }; // export the class\n\n\n  exports.Fuse = Fuse; // export a helper function to instantiate the Fuse class\n\n  exports.fuse = function (inputFile, outputFile, compress, mangle, lint) {\n    var fuser = new Fuse();\n    if (inputFile) fuser.set('inputFile', inputFile);\n    if (outputFile) fuser.set('outputFile', outputFile);\n    if (compress) fuser.set('compress', compress);\n    if (mangle) fuser.set('mangle', compress);\n    if (lint) fuser.set('lint', lint);\n    return fuser;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}