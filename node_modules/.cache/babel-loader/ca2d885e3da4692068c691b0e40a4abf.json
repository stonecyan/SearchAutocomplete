{"ast":null,"code":"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    module.exports = factory; // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory); // AMD\n  } else {\n    root.Mustache = factory; // <script>\n  }\n})(this, function () {\n  var exports = {};\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.2\";\n  exports.tags = [\"{{\", \"}}\"];\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/; // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  } // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n\n\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n\n\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n\n\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n\n\n  Scanner.prototype.scanUntil = function (re) {\n    var match,\n        pos = this.tail.search(re);\n\n    switch (pos) {\n      case -1:\n        match = this.tail;\n        this.pos += this.tail.length;\n        this.tail = \"\";\n        break;\n\n      case 0:\n        match = \"\";\n        break;\n\n      default:\n        match = this.tail.substring(0, pos);\n        this.tail = this.tail.substring(pos);\n        this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this._cache = {};\n  }\n\n  Context.make = function (view) {\n    return view instanceof Context ? view : new Context(view);\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name == '.') {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf('.') > 0) {\n            value = context.view;\n            var names = name.split('.'),\n                i = 0;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) break;\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === 'function') value = value.call(this.view);\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.getPartial = function (name) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    return this._partialCache[name];\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var self = this;\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === 'function') {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return renderTokens(tokens, self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n  /**\n   * Low-level function that renders the given `tokens` using the given `writer`\n   * and `context`. The `template` string is only needed for templates that use\n   * higher-order sections to extract the portion of the original template that\n   * was contained in that section.\n   */\n\n\n  function renderTokens(tokens, writer, context, template) {\n    var buffer = '';\n    var token, tokenValue, value;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      tokenValue = token[1];\n\n      switch (token[0]) {\n        case '#':\n          value = context.lookup(tokenValue);\n\n          if (typeof value === 'object') {\n            if (isArray(value)) {\n              for (var j = 0, jlen = value.length; j < jlen; ++j) {\n                buffer += renderTokens(token[4], writer, context.push(value[j]), template);\n              }\n            } else if (value) {\n              buffer += renderTokens(token[4], writer, context.push(value), template);\n            }\n          } else if (typeof value === 'function') {\n            var text = template == null ? null : template.slice(token[3], token[5]);\n            value = value.call(context.view, text, function (template) {\n              return writer.render(template, context);\n            });\n            if (value != null) buffer += value;\n          } else if (value) {\n            buffer += renderTokens(token[4], writer, context, template);\n          }\n\n          break;\n\n        case '^':\n          value = context.lookup(tokenValue); // Use JavaScript's definition of falsy. Include empty arrays.\n          // See https://github.com/janl/mustache.js/issues/186\n\n          if (!value || isArray(value) && value.length === 0) {\n            buffer += renderTokens(token[4], writer, context, template);\n          }\n\n          break;\n\n        case '>':\n          value = writer.getPartial(tokenValue);\n          if (typeof value === 'function') buffer += value(context);\n          break;\n\n        case '&':\n          value = context.lookup(tokenValue);\n          if (value != null) buffer += value;\n          break;\n\n        case 'name':\n          value = context.lookup(tokenValue);\n          if (value != null) buffer += exports.escape(value);\n          break;\n\n        case 'text':\n          buffer += tokenValue;\n          break;\n      }\n    }\n\n    return buffer;\n  }\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n\n\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          sections.push(token);\n          collector.push(token);\n          collector = token[4] = [];\n          break;\n\n        case '/':\n          var section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n          break;\n\n        default:\n          collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n\n\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n    var token, lastToken;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          lastToken = token;\n          squashedTokens.push(token);\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [new RegExp(escapeRe(tags[0]) + \"\\\\s*\"), new RegExp(\"\\\\s*\" + escapeRe(tags[1]))];\n  }\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n\n\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n    var sections = []; // Stack to hold section tokens\n\n    var tokens = []; // Buffer to hold the tokens\n\n    var spaces = []; // Indices of whitespace tokens on the current line\n\n    var hasTag = false; // Is there a {{tag}} on the current line?\n\n    var nonSpace = false; // Is there a non-space char on the current line?\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token;\n\n    while (!scanner.eos()) {\n      start = scanner.pos; // Match any text between tags.\n\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1; // Check for whitespace on the current line.\n\n          if (chr == '\\n') stripSpace();\n        }\n      } // Match the opening tag.\n\n\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true; // Get the tag type.\n\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe); // Get the tag value.\n\n      if (type === '=') {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRe('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      } // Match the closing tag.\n\n\n      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        if (sections.length === 0) throw new Error('Unopened section \"' + value + '\" at ' + start);\n        var openSection = sections.pop();\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n        if (tags.length !== 2) throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        tagRes = escapeTags(tags);\n      }\n    } // Make sure there are no open sections when we're done.\n\n\n    var openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    tokens = squashTokens(tokens);\n    return nestTokens(tokens);\n  }; // All Mustache.* functions use this writer.\n\n\n  var _writer = new Writer();\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n\n\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n\n\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n\n\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n\n\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n\n\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  }; // This is here for backwards compatibility with 0.4.x.\n\n\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n}());","map":null,"metadata":{},"sourceType":"script"}